---
layout:       post
title:        "HTTP/2"
subtitle:     "改革开放, 走进新时代"
date:         2018-11-26 12:00:00
author:       "Lorry"
header-mask:  0.3
header-img:   '/img/http2.png'
catalog:      true
multilingual: false
tags:
    - web
---
# http2是很早就想写的内容了, 这是 http/1.1以来跨版本的升级, 解决了以前很多问题, 可以大幅度的提高 http 的响应速度, 充分利用每一个 tcp 连接. 头图就是来自一个非常出名的 http/2的 [demo](https://http2.akamai.com/demo), 感兴趣的可以点进去看一下, 会有更直观的了解.

# 网络请求最主要的影响因素有两个 1 带宽 2 延迟

## 带宽

### 现在动辄百兆光纤入户, 带宽已经不再是很大的因素, 但是在网络刚起步的时候, 还是拨号上网, 带宽十分的珍贵, 所以那时候的网页不会像现在这样花里胡哨, 朴素很多.

这是2018年的雅虎主页: 

![](/img/yahoo_2018.png)

这是2000年的雅虎主页:

![](/img/yahoo_2000.png)

BTW, 推荐一个查看历史网页快照的网站, 需科学上网: https://web.archive.org, 上述图片均来自此.

## 延迟

### 延迟是 http 的天然缺陷, 从出生之初就有, 主要原因有以下几点:

- 查找 ip 需要 DNS 解析, 耗时.
- 找到 ip 后, 建立 TCP 的时间长, 需要三次握手以确保可靠性, 俗称慢启动
- 一条 TCP 连接无法复用, 每次请求都需要重新去建立 TCP
- 浏览器并发请求的数量有限, 大多数对同域下的请求数不超过6个<sup>[1]</sup>, 所以一旦有请求被阻塞, 就非常耽误加载时间.HOL(head-of-line) blocking--线头阻塞

线头阻塞: 源自[维基百科](https://en.wikipedia.org/wiki/Head-of-line_blocking)

![](/img/HOL_blocking.png)

### 在 Http/2以前有以下的解决方案:

- 设置请求头 Connection: Keep-Alive, 可定义是否一定时间内复用连接, 这个时间是由服务器决定, 且在现在移动 App 的使用场景下都是分散请求, 间隔时间不固定, 使用该方法有一定的局限性.
- 建立基于 tcp 的长连接, 比如socket, 但实现难度比较高
- long-polling, 极端情况下导致多个连接被挂起, 服务器压力增大
- streaming, 在 response 中增加`Transfer Encoding:chuncked` 或 `Content-Length: xxx` 来告诉客户端后续还有数据. 问题在于有些业务数据不能按照请求进行分割, 或者分割成本高
- websocket, 和传统的 tcp socket 类似, 提供双向的数据流, 比传统的更简单, 但技术较新, 不是所有浏览器都支持. 具体的分析可以看前文[Websockt](./2018-04-03-WebSocket.md)
- pipelining 解决请求阻塞.(图片源自[维基百科](https://en.wikipedia.org/wiki/HTTP_pipelining)), 请求不需要等待服务器响应, 可以全部发过去, 但是对请求方式限制(GET, HEAD), 且请求间相互不能依赖, 在2018年, 这个功能因为代理服务器和线头阻塞被默认关闭了.

![](/img/HTTP_pipelining.svg)

- SPDY, 支持对请求进行优先级排序和多路复用, 只需求一个 TCP 即可传输多个请求, 广泛使用了 TLS 加密, 传输内容也以 gzip 或 DEFLATE 格式压缩, 还可以主动推送内容.它相当于在 TCP 的 SSL 层上又新增了一层自有的 SPDY层, SPDY 之上为 HTTP层.可以很好的兼容老版本的 HTTP 协议. 在2015年谷歌宣布移除 SPDY 支持, 采用 HTTP/2. 这里只关注多路复用的特性. 

![](/img/spdy.png)

## 重点介绍 HTTP/2.0: SPDY 的升级版

### 与 SPDY 也有一些区别:

- 支持 HTTP 传输, SPDY 强制 HTTPS
- 消息头压缩算法采用 [HPACK](http://http2.github.io/http2-spec/compression.html), SPDY 采用 [DEFLATE](http://zh.wikipedia.org/wiki/DEFLATE)

### HTTP/2 与 HTTP/1.x 的区别
|特性| HTTP/2 | HTTP/1.x |优点|
|---|---|---|---|
|**解析格式**|二进制|文本|更健壮|
|**多路复用**|支持|http/1.0一个响应一个请求一个连接, http/1.1支持 pipeling, 但有HOLB|一个连接对应多个 request, 接收方根据 request_id 归属各自服务器|
|**header 压缩**|支持|不支持|使用 encoder 减少 header 大小, 通讯双方均缓存一份 header fields 字段表, 避免重复传输, 也减小传输大小|
|**服务端推送**|支持|不支持|消息应用, 提前把需要的 js,css跟着 index 请求响应, 之后直接从缓存拿|

### 重点介绍一下对速度影响很大的几个因素: 1 多路复用 2 header 压缩
#### 多路复用可以很好的利用 TCP 连接特性
在连接初期限制最大速度, 数据成功传输以后随着时间推移提高速度, 俗称的 TCP慢启动, 但是 HTTP 是突发性和短时性的, 就像刚从国道开进高速收费站, 正准备上高速, 撒开丫子跑, 然后说mission complete, 不用开了. 如果可以在高速上持续的开上一段时间, 就可以极大的提示响应速度. 
SPDY和 HTTP/2 就是在里面家里一层二进制层, 就相当于多了一个维度, 不用把车开回去运请求, 而是可以把请求都放进这个正在跑的车里, 车只管开.自然速度提升很快
再次祭出该图片, 直观说明了为什么连接会很快. 

![](/img/spdy.png)

##### 给我最大的感受就是再也不用雪碧图了, 可以直接一个一个请求, 因为每次请求不会有额外的请求头消耗.它还有其他的特性:

- 插入多个平行的请求而不用阻塞其他任何请求
- 插入多个平行的响应而不用阻塞其他任何请求
- 使用单个连接传输多个平行的请求或响应
- 移除不必要的 HTTP/1.X 的优化方法, (pipeling, domain sharding--将资源分配6个 domain, bundle resources--**sprite**, inline small resources--base64)
- 通过移除不必要的延迟降低页面载入次数并且提高网络利用率



#### header 压缩


# 引用

[1] Ilya Grigorik , High Performance
Browser Networking(2013), chapter11 HTTP/1.X, https://hpbn.co/http1x/#using-multiple-tcp-connections