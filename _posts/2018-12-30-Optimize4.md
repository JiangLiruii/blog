---
layout:       post
title:        "浏览器API和协议"
subtitle:     "无线通信"
date:         2018-12-30 12:00:00
author:       "Lorry"
header-mask:  0.3
header-img:   '/img/Fast-Moving-Light-Wallpaper.jpg'
catalog:      true
multilingual: false
tags:
    - web
---

# 浏览器网络概述

![](/img/Optimize/High_level_browser_API.svg)

现代浏览器不仅仅是一个简单的套接字管理器. 从表明看是一套资源获取机制, 但实质也有自己的平台, 由自己的优化标准, API和服务, 如上图所示

## 连接管理和优化
- Web应用不会维护单个网络套接字的生命周期,而是委托给浏览器
- 自动化关键性能优化
  - 套接字重用
  - 请求优先级
  - late binding晚绑定
  - 协议协商
  - 强制连接限制
- 将**请求生命周期管理**和**套接字管理**区分

套接字池, 由源分组得到, 每个吃由自己的连接限制和安全约束. 延迟的请求正在排队, 排优先级, 然后绑定到池中单独的套接字上.除非服务端故意关闭连接, 同一个socket可以自动对多个请求重用

![](/img/Optimize/Auto_managed_socket.svg)

- 源
  - 应用协议
  - domain name
  - port number
  - (http, www.example.com, 80)
- Socket pool
  - 一组属于同一个origin的sockets
  - 常用网络最大pool 为6个套接字
套接字池管理可以自动重用TCP连接.还有以下的优化:
- 按照请求优先级排队
- 重用socket最小化延迟和提升吞吐量
- 预先打开socket去参与请求
- 优化和是关闭空闲sockets
- 优化所有sockets分配的带宽 

## 网络安全和沙盒
将不信任的应用代码放到沙盒中运行, 保障安全性, 比如浏览器不允许直接的API连接原生网络套接字
- 连接限制
  - 浏览器管理所有打开的socket池
  - 规定连接数量
- 请求格式化和响应处理
  - 格式化所有外发的请求保证格式一致, 符合协议的语义, 保护服务端
  - 响应也会处理, 保护客户端
- TLS协商
  - 浏览器进行TLS握手和必要的证书检查
  - 验证失败用户会得到警告, 比如服务端的自签名证书
- 同源策略
  - 浏览器强制应用请求必须是发至某个origin
## 资源和客户端缓存
最快的请求就是不请求.缓存就是让浏览器不发请求而直接从缓存中获取资源.
- 浏览器评估每个资源的缓存指令(Cache-Control, Etag, Las-Modified)
- 自动再验证过期资源
- 自动管理缓存大小和资源回收
- 提供会话验证和cookie管理
  - 一个会话认证可以在多个标签和窗口中共享
  - 一个窗口或标签也可以共享多个会话认证
  - 一旦用户注销之后, 其他打开窗口的会话都会失效


## 应用API和协议

没有一个最好的协议或API, 各有所长

|	|XMLHttpRequest	|Server-Sent| Events|	WebSocket|
|---|---|---|---|---|
|Request streaming	|no	|no	|yes|
|Response streaming	|limited|	yes	|yes|
|Framing mechanism	|HTTP	|event stream|	binary framing|
|Binary data transfers	|yes	|no (base64)|	yes|
|Compression	|yes|	yes|	limited|
|Application transport protocol	|HTTP|	HTTP|	WebSocket|
|Network transport protocol	|TCP|	TCP	|TCP|

> 故意忽略了WebRTC, 因为他是P2P的传输模型

# XMLHttpRequest
XHR是浏览器级别的API, 可以允许客户端使用js传输数据. 它是AJAX背后的关键技术.
- 浏览器负责管理连接的建立, pooling和termination
- 浏览器决定最好的HTTP(S)传输(HTTP/1.x,2)
- 浏览及处理HTTP缓存, 重定向和内容类型协商
- 浏览器强制安全, 授权和隐私限制


## XHR的历史
最早只是浏览器的自我实现, 2006年W3C才颁布了XHR标准, 2008年又颁布了XHR level2, 包含的新特性有:
- 支持请求超时
- 支持二进制和基于文本的数据传输
- 支持应用覆盖媒体类型和响应编码
- 支持每个请求的进程
- 支持高效的文件上传
- 支持安全的跨域请求
2011年, XML level2标准也合并到最初的XHR标准里了.
## 跨域请求CORS
应用提供数据和URL, 浏览器格式化请求并处理每个连接的整个生命周期, 应用可以自定义请求头字段(setRequestHeader()), 也有下列几个保留请求头
- Accept-Charset, Accept-Encoding, Access-Control-*
- Host, Upgrade, Connection, Referer, Origin
- Cookie, Sec-*, Proxy-*
保护Origin头至关重要, 因为直接影响同源策略, 为什么要有同源?
浏览器储存了很多用户数据, 比如鉴权的token, cookies,和其他隐私数据, 如果thirdparty.com可以被加载, 那么它也可以访问到origin.com的个人数据, 是十分危险的.

那如果非要从不同的源或去资源呢? CORS就来了

```
// script origin: (http, example.com, 80)
var xhr = new XMLHttpRequest();
// same origin request
xhr.open('GET', '/resource.js'); 
xhr.onload = function() { ... };
xhr.send();

var cors_xhr = new XMLHttpRequest();
// cross origin request
cors_xhr.open('GET', 'http://thirdparty.com/resource.js'); 
cors_xhr.onload = function() { ... };
cors_xhr.send();
```

同域和跨域在API层看来是只有url的区分的

以下是跨域的请求报文, Origin是浏览器自动设置的, Access-Control-Allow-Origin是可选的服务器设置头, 可见thirdparty.com是允许example origin访问的, 如果想拒绝访问, 那么忽略这个属性即可.如果设置为 * 则是表示任意origin都可访问, 设置时请三思

```
=> Request
GET /resource.js HTTP/1.1
Host: thirdparty.com
Origin: http://example.com 
...

<= Response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://example.com
```
CORS提供了额外的安全预警保证服务器可以知道CORS
- CORS请求忽略用户验证比如cookies和HTTP鉴权
- 客户端被限制在简单的跨域请求, 指能使用GET, POST HEAD方法, 并且HTTP头可以被发送端和接收端都获取到

为了可以使用cookie和HTTP鉴权, 客户端必须设置一个额外的属性 **withCredentials**, 服务端也必须响应合适的头(Access-Control-Allow-Credentials)编码知道允许应用包含用户隐私数据. 类似的, 如果像自定义不同的方法, 可以使用Access-Control-Allow-Headers: My-Custom-Header进行预请求
```
=> Preflight request

OPTIONS /resource.js HTTP/1.1 
Host: thirdparty.com
Origin: http://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: My-Custom-Header
...

<= Preflight response
HTTP/1.1 200 OK 
Access-Control-Allow-Origin: http://example.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: My-Custom-Header
...

(actual HTTP request) 
```
使用OPTIONS预请求验证permission
third-party origin成功预响应

可以看到, 预请求需要多收发一次数据, 会增加网络延迟, 但是浏览器会缓存, 避免每个请求都进行相同的验证

## XHR下载数据
XHR可以传输两类数据
1. 基于文本
2. 二进制数据

浏览器可以自动的为各种原生数据类型编码或解码
- ArrayBuffer
  - 定长二进制数据buffer
- Blob
  - 不变的数据的二进制大对象
- Document
  - 实例化的HTML和XML文档
- JSON
  - 代表简单数据结构的Javascript对象
- Text
  - 简单文本字符串

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/images/photo.webp');
// 定义返回数据类型为blob
xhr.responseType = 'blob'; 

xhr.onload = function() {
  if (this.status == 200) {
    var img = document.createElement('img');
    // 创建唯一对象URI并设置到src中
    img.src = window.URL.createObjectURL(this.response); 
    img.onload = function() {
        // 图片加载之后释放对象URI
        window.URL.revokeObjectURL(this.src); 
    }
    document.body.appendChild(img);
  }
};

xhr.send();
```
## XHR上传数据
上传数据与下载数据只有send方法不一样, 其他的都差不多
```js
var xhr = new XMLHttpRequest();
xhr.open('POST','/upload');
xhr.onload = function() { ... };
// 上传字符串到服务器
xhr.send("text string"); 

// 创建一个动态的表格
var formData = new FormData(); 
formData.append('id', 123456);
formData.append('topic', 'performance');

var xhr = new XMLHttpRequest();
xhr.open('POST', '/upload');
xhr.onload = function() { ... };
// 发送该表格对象给服务器
xhr.send(formData); 

var xhr = new XMLHttpRequest();
xhr.open('POST', '/upload');
xhr.onload = function() { ... };
var uInt8Array = new Uint8Array([1, 2, 3]); 
// 发送二进制文件
xhr.send(uInt8Array.buffer); 
```
send中的参数支持
- DOMString
- Document
- FormData
- Blob
- File
- ArrayBuffer对象
会根据以上的参数类型自行编码并设置对应的HTTP content-type, 然后发送请求.如果需要用户自行上传文件: 获取对象的引用并传给XHR
```js
var blob = ArrayBuffer([1,2,3]);

// 设置每个chunk的大小为1MB
const BYTES_PER_CHUNK = 1024*1024;
const SIZE = blob.size;

var start = 0;
var end = BYTES_PER_CHUNK;

while(start < SIZE) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/upload');
    xhr.onload = () => console.log('xhr load finished')

    // 设置请求头为Content-Range start-end/total
    xhr.setRequestHeader('Content-Range', start+'-'+end+'/'+SIZE);
    xhr.send(blob.slice(start, end));

    start = end;
    end = start + BYTES_PER_CHUNK;
}
```
分块的好处是如果其中一块传输失败之后, 不用整个blob重试, 而只需要重试这一个分块即可
## 监听下载和上传过程
XHR提供了API去监听过程时间, 表明请求当前状态
|Event type	|Description	|Times fired|
|---|---|---|
|loadstart	|Transfer has begun|	once|
|progress	|Transfer is in progress|	zero or more|
|error	|Transfer has failed|	zero or once|
|abort	|Transfer is terminated|	zero or once|
|load	|Transfer is successful	|zero or once|
|loadend	|Transfer has finished	|once|

所有的XHR都是以loadstart开头, loadend结尾

```js
var xhr = new XMLHttpRequest();
xhr.open('GET','/resource');
xhr.timeout = 5000; 

// 注册成功请求回调
xhr.addEventListener('load', function() { ... }); 
// 注册失败回调
xhr.addEventListener('error', function() { ... }); 

// progress时间处理函数
var onProgressHandler = function(event) {
  if(event.lengthComputable) {
    var progress = (event.loaded / event.total) * 100; 
    ...
  }
}

// 在XHR上传中注册progress事件
xhr.upload.addEventListener('progress', onProgressHandler); 
// 在XHR下载中注册progress事件
xhr.addEventListener('progress', onProgressHandler); 
xhr.send();
```

XHR是没有超时的, 意味着"in progress"状态可以持续永久, 最佳实践是在应用中使用有意义的timeout超时处理错误.
## XHR的流数据
在官方标准中没有正式的流使用案例, 但是又有使用场景:
- 在客户端可用时上传数据
- 在数据到达服务端后下载数据
限制有两点:
1. **send**方式在上传过程中需要完整的payload
2. **response, responseText, ResponseXML**属性不能赋值给流

现在正在出台相应的流标准, 能绕过的只有下载, 上传还不行
```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/stream');
xhr.seenBytes = 0;

xhr.onreadystatechange = function() { // 监听状态变化
  if(xhr.readyState > 2) {
    var newData = xhr.responseText.substr(xhr.seenBytes); // 从partial response中解压新的数据
    // process newData

    xhr.seenBytes = xhr.responseText.length; // 更新处理字节的offset 
  }
};

xhr.send();
```
上述方案可以在大多数浏览器中使用, 但是性能不是很好.
- 手动追踪seenBytes,并切片, **responseText**是一个完整的响应, 对小传输来说不是问题, 但是如果是大文件的下载, 特别是对内存限制的移动端,就是问题.释放响应buffer的唯一方法是完成这个请求, 打开另一个
- partial response只能在responseText属性中获取, 这限制了只能使用text-only传输, 没有办法传输二进制
- 一旦partial data被读取, 必须验证消息边界, 应用逻辑必须定义自己的数据格式, 然后缓存并实例这个流去解压缩单个消息
- 浏览器对待接收到的数据缓存有区别, 有的可以立即释放数据, 有的会缓存小响应, 在大的chunk中释放
- 浏览器对渐进式读取的content-type要求不一, 有的要求text/html, 有的只在application/x-javascript

综上, XHR不适合进行流的传输.
> XHR不适合, 还有SSE(server only text-based)和WebSocket(bidirectional text-based&binary)
## 实时消息提醒和传输
客户端可以发请求更新数据, 但是如果服务端有数据更新需要通知客户端怎么办?
### polling轮询
客户端周期性发送请求询问服务端是否有数据,如果服务端有响应则返回, 否则响应空. 这个周期的选择就很重要. 长了无法保证实时性, 短了造成不必要payload

```js
function checkUpdates(url) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function() { ... }; 
  xhr.send();
}

// 每60s发一次请求
setInterval(function() { checkUpdates('/updates') }, 60000);
```
轮询适合实践间隔长, 且服务器会周期性发送数据, 传输的数据也大的应用, 假设一个邮件的应用

- 每60s, 客户端发送一个XHR请求检查更新
- 每个XHR请求会包含最新的消息ID
- 服务器比较客户端ID和它自己的消息列表
- 服务器响应一个新的列表或空列表(无更新)
- 平均邮件的延时: 30s
- 轮询的overload: 平均HTTP/1.x的overhead为800字节, 因为客户端是登陆态, 还需要额外的权限cookie和消息ID, 就有了另外50bytes, 所以请求的overhead为850bytes, 如果有10000个客户端, 所有的轮询都是60s(每秒167个请求), 那么overload就为: (850bytes * 8bits * 10000)/60s = 1.13Mbps, 这就是不含任何新消息给客户端的恒定的速率.
- 是不是interval太长了, delay为30s接收不了?可以, 减小interval会导致更高的吞吐量和overhead.(除数变小了)

长轮询的问题就在于如果没有数据更新会发多余的请求, 那么换个方式, 让每次的请求都保持住, 等到服务器有更新的时候再响应?

![](/img/Optimize/long_polling_latency.svg)

这就是长轮询 long-polling, 

```js
function checkUpdates(url) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.onload = function() { // 收到更新, 处理更新数据
    ...
    checkUpdates('/updates'); // 打开新的长轮询XHR, 持续循环
  };
  xhr.send();
}

checkUpdates('/updates'); // 初始化轮询
```
长轮询动态调整消息到达速率来最小化消息延迟. 

oerload的性能呢? 其实也不高, 因为每个连接都是新的连接, 都需要加额外的overload, 如果服务端的message发送速率很高, 长轮询就会比周期轮询产生更多的overload. 周期轮询相当于是只检验最新的message(message 聚合), 可以减少请求的数量, 优化手持设备的电池寿命

## XHR 使用案例和性能
几行js代码(new, open, send, onload即可), 浏览器自动帮我们处理的事情:
- 格式化HTTP请求和实例化响应
- 强制相关策略, 比如同源
- 处理内容协商(gzip)
- 处理请求和响应缓存
- 处理授权信息, 重定向等

但是也有局限
- 没有官方的XHR标准
- stream既不高效也不方便
- 不同浏览器有不同行为
- 高效的二进制分帧时不可能的
- 总而言之, **XHR对流很不友好**
- 实时传输策略也不完美, 虽然有periodic polling和long-polling
- 
# 服务端推送时间SSE
## EventSource API
## Event Stream 协议
## SSE使用案例和性能

# WebSocket
## WebSocket API
## Websocket 协议
## Websocket使用案例和性能
## 性能检测清单

# WebRTC
## WebRTC标准
## 音视频引擎
## 实时网络传输
## 传输媒体和应用数据
## 数据信道DataChannel
## WebRTC 使用案例和性能
## 性能检测清单