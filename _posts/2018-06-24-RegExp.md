---
layout:       post
title:        "RegExp"
subtitle:     "人海茫茫,找到合适的那一个岂止简单?"
date:         2018-06-21 12:00:00
author:       "Lorry"
header-mask:  0.3
header-img:   'http://p799phkik.bkt.clouddn.com/promise.jpg'
catalog:      true
multilingual: false
tags:
    - JavaScript
---
# 前言
使用正则,可以少写很多的判断,使代码更加的优雅,可以从字符串当中拿出任何你需要的字符,然后进行加工,得到你想要的任何结果,听起来是不是很棒?

然而正则的表达式看起来不是那么的浅显易懂,往往通用的东西都会更加的抽象,只有抽象出来,才能普适.

# 正文
## 从创建说起 两种创建方式: 1 new RegExp 2 / /, 推荐用后一种,除非是需要动态创建用第一种更好.

```js
const dynamicReg = 'some_sort_variable'
const test = new RegExp(dynamicReg, 'ig')

const literal1 = /some_sort_variable/ig
const literal2 = /some_sort_variable/ig

console.log(literal1.toString() === test.toString()) // true
console.log(literal1 === literal2) // false,所有的正则都是新的对象

// 用于动态(运行时)创建
function findClassInElement(className, type) {
  const elems = document.getElementsByClassNames(type);
  const re = new RegExp("(\\s|^)" + className + "(\\s|$)") // <div class='foo bar zoo'></div>
  let result = [];
  for (let elem in elems) {
    if (re.test(elem.className)) {
      result.push(elem)
    }
  }
}
```

## 字符集 [],表示中括号中的任意一个字符匹配

```js
const test = /[abc]/ // 匹配a或b或c而不是abc
const test2 = /[^abc]/ // 匹配非a非b非c的任意字符
```

## 特殊字符 

- ^ 开始符
- $ 结束符
- . 匹配任何字符
- ? 匹配0个或1个,用于非贪婪匹配
- + 匹配一个或多个
- * 匹配0个,1个或多个
- \ 匹配特殊字符
- () 分组(?:)或捕获
- | 或
- \1,\2 back reference, 获取对应位置的匹配值
```js
const re = /<(\w+)[^>]*>(.*)?<\/\1>/ // <div></div> 
```

## 方法

- test 返回是否满足对应规则
- match 
  - 本地的match,不带/g,返回所有匹配值和捕获值
  - 全局的match,带/g, // 返回所有匹配值(没有捕获值)
```js
const test_string = "I am Lorry"
const match1 = test_string.match(/(\w+)\s/) // [ "I ", "I" ]
const match2 = test_string.match(/(\w+)\s/g) // [ "I ", "am "]
```
- exec
  - 跟生成器一样,一个一个的往下匹配
  - 包含匹配的值(result[0]),也包含捕获的值(对应序列)